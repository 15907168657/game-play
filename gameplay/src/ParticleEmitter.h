/*
 * ParticleEmitter.h
 */

#ifndef PARTICLEEMITTER_H_
#define PARTICLEEMITTER_H_

#include "Transform.h"
#include "Mesh.h"
#include "Vector2.h"
#include "Color.h"
#include "Texture.h"
#include "Rectangle.h"
#include "SpriteBatch.h"

namespace gameplay
{

class Node;

/**
 * Defines a particle emitter.
 */
class ParticleEmitter : public Ref
{
    friend class Node;

public:

    /**
     * Creates a particle emitter from a file.
     */
    static ParticleEmitter* create(const char* particleFile);

    /**
     * Creates an empty ParticleEmitter.
     */
    static ParticleEmitter* create(const char* texturePath, unsigned int particleCountMax);

    /**
     * Gets the current number of particles.
     *
     * @return The number of particles that are currently alive.
     */
    unsigned int getParticlesCount() const;

    /**
     * Gets the node that this emitter is attached to.
     *
     * @return The node that this emitter is attached to.
     */
    Node* getNode() const;

    /**
     * Sets whether the vector properties of newly emitted particles are rotated around the node's position
     * by the node's rotation matrix.
     */
    void setOrbitAroundOrigin(bool orbitPosition, bool orbitVelocity, bool orbitAcceleration);

    /**
     * Sets whether the positions of newly emitted particles are generated within an ellipsoidal domain.
     *
     * Each vector property is generated such as to fall within the domain defined by a base vector and a
     * variance vector.
     *
     * If that domain is ellipsoidal, vectors are generated within an ellipsoid centered at the base vector
     * and scaled by the variance vector.
     *
     * If that domain is not ellipsoidal, vectors are generated by multiplying the variance vector by a random
     * floating-point number between -1 and 1, then adding this result to the base vector.
     *
     * Ellipsoidal domains are somewhat less efficient and only necessary when determining the positions of
     * newly emitted particles.  Call this method with 'true' to make initial position an ellipsoidal domain.
     * The default setting is 'false'.
     */
    void setEllipsoid(bool ellipsoid);

    /**
     * Gets the minimum size that each particle can be at the time when it is started.
     *
     * @return The minimum size that each particle can be at the time when it is started.
     */
    float getSizeStartMin() const;

    /**
     * Gets the maximum size that each particle can be at the time when it is started.
     *
     * @return The maximum size that each particle can be at the time when it is started.
     */
    float getSizeStartMax() const;

    /**
     * Gets the minimum size that each particle can be at the time when it is ended.
     *
     * @return The minimum size that each particle can be at the time when it is ended.
     */
    float getSizeEndMin() const;

    /**
     * Gets the maximum size that each particle can be at the time when it is ended.
     *
     * @return The maximum size that each particle can be at the time when it is ended.
     */
    float getSizeEndMax() const;

    /**
     * Sets the minimum and maximum size that each particle can be at the time when it is spawned,
     * as well as the minimum and maximum size for particles to be at the end of their lifetimes.
     */
    void setSize(float startMin, float startMax, float endMin, float endMax);
    
    const Color& getColorStart() const;

    const Color& getColorStartVariance() const;

    const Color& getColorEnd() const;

    const Color& getColorEndVariance() const;

    void setColor(const Color& start, const Color& startVariance, const Color& end, const Color& endVariance);

    void setColor(const Color& start, const Color& end);

    void setColorVariance(const Color& startVariance, const Color& endVariance);

    /**
     * Gets the minimum lifetime of each particle, measured in milliseconds.
     *
     * @return The minimum lifetime of each particle, measured in milliseconds.
     */
    long getEnergyMin() const;

    /**
     * Gets the maximum lifetime of each particle, measured in milliseconds.
     *
     * @return The maximum lifetime of each particle, measured in milliseconds.
     */
    long getEnergyMax() const;

    /**
     * Sets the minimum and maximum lifetime of emitted particles, measured in milliseconds.
     *
     * @param min The minimum lifetime of each particle, measured in milliseconds.
     * @param max The maximum lifetime of each particle, measured in milliseconds.
     */
    void setEnergy(long min, long max);
    
    /**
     * Gets the emission rate, measured in particles per second.
     *
     * @return The emission rate, measured in particles per second.
     */
    unsigned int getEmissionRate() const;

    /**
     * Sets the emission rate, measured in particles per second.
     *
     * @param rate The emission rate, measured in particles per second.
     */
    void setEmissionRate(unsigned int rate);

    /**
     * Gets the position of new particles, relative to the emitter's transform.
     *
     * @return The position of new particles, relative to the emitter's transform.
     */
    const Vector3& getPosition() const;

    /**
     * Gets the position variance of new particles.
     *
     * @return The position variance of new particles.
     */
    const Vector3& getPositionVariance() const;

    /**
     * Sets the initial position and position variance of new particles.
     *
     * @param position The initial position of new particles.
     * @param positionVariance The amount of variance allowed in the initial position of new particles.
     */
    void setPosition(const Vector3& position, const Vector3& positionVariance);

    /**
     * Gets the initial velocity of new particles.
     *
     * @return The initial velocity of new particles.
     */
    const Vector3& getVelocity() const;

    /**
     * Gets the initial velocity variance of new particles.
     *
     * @return The initial velocity variance of new particles.
     */
    const Vector3& getVelocityVariance() const;

    /**
     * Sets the base velocity of new particles and its variance.
     *
     * @param velocity The initial velocity of new particles.
     * @param velocityVariance The amount of variance allowed in the initial velocity of new particles.
     */
    void setVelocity(const Vector3& velocity, const Vector3& velocityVariance);

    const Vector3& getAcceleration() const;

    const Vector3& getAccelerationVariance() const;

    void setAcceleration(const Vector3& acceleration, const Vector3& accelerationVariance);

    /**
     * Gets the minimum angular velocity of new particles.
     */
    float getAngularVelocityMin() const;

    /**
     * Gets the angular velocity variance of new particles.
     */
    float getAngularVelocityMax() const;

    /**
     * Sets the angular velocity around an axis of emitted particles.
     */
    void setAngularVelocity(float min, float max);

    /**
     * Sets the blend mode used by this particle emitter.
     */
    void setBlendMode(const GLenum sfactor, const GLenum dfactor);

    /**
     * New particles are created with one of the sprite frames in the emitter's texture.
     * If a maximum offset is set, a random frame from 0 to maxOffset will be selected.
     * Set maxOffset to 0 (the default) for all particles to start on the first frame.
     * maxOffset will be clamped to frameCount.
     */
    void setSpriteRandomOffset(int maxOffset);

    /**
     * If sprites are set to loop, each frame will last for the emitter's frameDuration.
     * If sprites are set not to loop, the animation will be timed so that the last frame
     * finishes just as a particle dies.
     * Note: This timing is calculated based on a spriteRandomOffset of 0.
     * For other offsets, the final frame may be reached earlier.
     * If sprites are not set to animate, this setting has no effect.
     *
     * @see ParticleEmitter::setSpriteFrameDuration
     */
    void setSpriteLooped(bool looped);

    /**
     * Sets whether particles cycle through the sprite frames.
     */
    void setSpriteAnimating(bool animating);

    /**
     * If sprites are set to loop, each frame will last for this duration.
     */
    void setSpriteFrameDuration(long duration);

    /**
     * Sets texCoords manually.
     */
    void setSpriteTexCoords(unsigned int frameCount, float* texCoords);

    /**
     * Sets coords in pixels.
     */
    void setSpriteFrameCoords(unsigned int frameCount, Rectangle* frameCoords);

    /**
     * When all frames are the same size, this method should be useful.
     * This might even be the only method we should make public.
     */
    void setSpriteFrameCoords(unsigned int frameCount, int width, int height);

    /**
     * Starts emitting particles over time.
     */
    void start();

    /**
     * Stops emitting particles over time.
     */
    void stop();

    /**
     * Generates an arbitrary number of particles all at once.
     */
    void emit(unsigned int particleCount);

    /**
     * Updates the particle system.
     */
    void update(long elapsedTime);

    /**
     * Renders the particle system.
     */
    void draw();

private:

    /**
     * Constructor.
     */
    ParticleEmitter(unsigned int particlesCount, SpriteBatch* batch);

    /**
     * Destructor.
     */
    virtual ~ParticleEmitter();

    /**
     * Sets the node that this emitter is attached to.
     */
    void setNode(Node* node);

    /**
     * Generates a scalar within the range defined by min and max.
     */
    float generateScalar(float min, float max);

    long generateScalar(long min, long max);

    /**
     * Generates a vector within the domain defined by a base vector and its variance.
     */
    inline void generateVectorInRect(const Vector3& base, const Vector3& variance, Vector3* dst);

    /**
     * Generates a vector within the ellipsoidal domain defined by a center point and scale vector.
     */
    void generateVectorInEllipsoid(const Vector3& center, const Vector3& scale, Vector3* dst);

    inline void generateVector(const Vector3& base, const Vector3& variance, Vector3* dst, bool ellipsoid);

    /**
     * Generates a color within the domain defined by a base vector and its variance.
     */
    void generateColor(const Color& base, const Color& variance, Color* dst);

    /**
     * Defines the data for a single particle in the system.
     */
    class Particle
    {

    public:
        Vector3 _position;
        Vector3 _velocity;
        Vector3 _acceleration;
        Color _colorStart;
        Color _colorEnd;
        Color _color;
        float _angularVelocity;
        float _angle;
        long _energyStart;
        long _energy;
        float _sizeStart;
        float _sizeEnd;
        float _size;
        unsigned int _frame;
        float _timeOnCurrentFrame;
    };

    unsigned int _particleCountMax;
    unsigned int _particleCount;
    Particle* _particles;
    SpriteBatch* _spriteBatch;
    Node* _node;
    bool _active;
    bool _orbitPosition;
    bool _orbitVelocity;
    bool _orbitAcceleration;
    bool _ellipsoid;
    float _sizeStartMin;
    float _sizeStartMax;
    float _sizeEndMin;
    float _sizeEndMax;
    float _energyMin;
    float _energyMax;
    float _angularVelocityMin;
    float _angularVelocityMax;
    Color _colorStart;
    Color _colorStartVar;
    Color _colorEnd;
    Color _colorEndVar;
    Vector3 _position;
    Vector3 _positionVar;
    Vector3 _velocity;
    Vector3 _velocityVar;
    Vector3 _acceleration;
    Vector3 _accelerationVar;
    unsigned int _emissionRate;
    long _timePerEmission;
    long _timeLast;
    long _timeRunning;
    
    // Sprite animation settings.
    unsigned int _spriteFrameCount;
    long _spriteFrameDuration;
    float _spriteFrameDurationSecs;
    float _spritePercentPerFrame;
    unsigned int _spriteRandomOffset;
    bool _spriteLooped;
    bool _spriteAnimating;

    // Texture metadata.
    float* _texCoords;
    float _textureWidth;
    float _textureHeight;
    float _textureWidthRatio;
    float _textureHeightRatio;
};

}

#endif
